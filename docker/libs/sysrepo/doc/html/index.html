<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>sysrepo: Introduction</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="logo.png"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">sysrepo
   &#160;<span id="projectnumber">1.4.70</span>
   </div>
   <div id="projectbrief">YANG datastore</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('index.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="headertitle">
<div class="title">Introduction </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p><a class="anchor" id="main"></a></p>
<h1>About</h1>
<p><a class="anchor" id="about"></a> Sysrepo is a YANG-based datastore for Unix/Linux systems. Applications that have their configuration modelled using YANG can use Sysrepo for its management.</p>
<p>There are 2 main approaches for applications to make use of Sysrepo. The <b>direct approach</b> involves calling Sysrepo functions from the application itself whenever configuration data are needed or executing specific callbacks to react to configuration changes. It is also possible to implement a stand-alone daemon that will translate Sysrepo calls to actions specific for the application. This <b>indirect approach</b> is usually simpler to employ for existing applications because then they do not need to be changed themselves to utilize Sysrepo datastore at the cost of having an additional intermediary process (daemon). If there are several such daemons, they can be written as <a class="el" href="sysrepo_plugind.html">plugins</a> and then all managed by one process.</p>
<div class="image">
<img src="sr_apps.png" alt="sr_apps.png"/>
<div class="caption">
Sysrepo application approaches</div></div>
 <h2>Adopted RFCs</h2>
<p><a class="anchor" id="rfcs"></a></p><ul>
<li><a href="https://tools.ietf.org/html/rfc6241">RFC 6241</a> NETCONF 1.1<br />
 Sysrepo does not strictly conform to this RFC but was developed to also have a remote NETCONF interface so it is followed to the relevant extent.</li>
<li><a href="https://tools.ietf.org/html/rfc7950">RFC 7950</a> YANG 1.1<br />
 Core YANG specification.</li>
<li><a href="https://tools.ietf.org/html/rfc8342">RFC 8342</a> NMDA<br />
 Datastore definitions.</li>
<li><a href="https://tools.ietf.org/html/rfc5277">RFC 5277</a> NETCONF Event Notifications<br />
 Definitions for notifications and their subscriptions.</li>
</ul>
<h2>General Principles</h2>
<p><a class="anchor" id="principles"></a></p><ul>
<li>Sysrepo is <b>only a library</b> so there is no stand-alone process</li>
<li>all data are always <b>separated by YANG schemas</b> which has many consequences such as allowing concurrent work with different schemas</li>
<li><b>fixed YANG schema set</b> that cannot be modified during Sysrepo operation (more in <a class="el" href="schema.html">schemas</a>)</li>
<li><b>shared memory</b> is used for almost all IPC</li>
<li>almost <b>no CPU time wasted</b> in the library (no active waiting or periodic checks)</li>
<li>fully customizable <b>event handling</b> from periodic checks or using <code>poll(2)</code>/<code>select(2)</code> to automatic thread handlers creation (more in <a class="el" href="index.html#threads">threading</a>)</li>
<li><b>access control</b> relies strictly on the file system (more in <a class="el" href="index.html#access_control">access control</a>)</li>
<li><a href="https://github.com/CESNET/libyang">libyang</a> is a critical part and is often used directly in API so one should be familiar with it before working with Sysrepo</li>
<li>most API calls working with data <b>have 2 variants</b>, one using <em>libyang</em> structures, another accepting Sysrepo <a class="el" href="group__get__data__api.html#ga3622da231931a47e9ac400561fbe80e2" title="Structure that contains value of an data element stored in the sysrepo datastore. ...">sr_val_t</a> structures (more in the next section)</li>
</ul>
<h1>Main Features</h1>
<p><a class="anchor" id="features"></a> Main Sysrepo features are manipulation with YANG data and subscribing to various events. However, before any operation can be performed, a <a class="el" href="conn_sess.html">connection and session</a> needs to be created and all the supported YANG <a class="el" href="schema.html">schemas</a> installed. Sysrepo can also keep records of its behaviour if <a class="el" href="log.html">logging</a> is configured. Finally, despite being only a library, there are a few auxiliary <a class="el" href="bins.html">utilities</a> that use the API in some common ways.</p>
<p>Almost all API functions that work with data have 2 variants, each accepting the data in another format. An array of <a class="el" href="group__get__data__api.html#ga3622da231931a47e9ac400561fbe80e2" title="Structure that contains value of an data element stored in the sysrepo datastore. ...">sr_val_t</a> values can be used. This format is a legacy one and <b>should not be used</b> in new applications. The alternative is using native <em>libyang</em> tree structures (API functions suffixed with <code>_tree()</code>) that Sysrepo always works with internally. It has the advantage of being more efficient (no internal conversion is needed) and having an extended <em>libyang</em> API available for creating/modifying/printing.</p>
<p><a class="el" href="edit_data.html">Editing data</a> is simple but requires basic knowledge of XPath for addressing individual data nodes. <a class="el" href="get_data.html">Getting data</a> also uses XPath but for this purpose almost any valid expression can be used. If an exlusive access to certain data is required, <a class="el" href="lock.html">locking</a> is available.</p>
<p>The most common and useful kind of <a class="el" href="subs.html">subscriptions</a> are <a class="el" href="subs.html#change_subs">change</a> subscriptions, which allow applications to perform actions based on specific data changes using callbacks. This way Sysrepo acts as a smarter configuration file. In addition, <a class="el" href="subs.html#rpc_subs">RPC/action</a> and <a class="el" href="subs.html#notif_subs">notification</a> subscriptions are supported so that a specifc RPC can be executed and other Sysrepo clients can be notified about various generated events, respectively. It is also possible to expose some state data using <a class="el" href="subs.html#oper_subs">operational subscriptions</a> that are only for reading. These subscriptions, however, allow much more in order for NMDA <em>operational</em> datastore to be fully supported with all of its properties.</p>
<h1>Datastores</h1>
<p><a class="anchor" id="datastores"></a> Datastores mostly follow the architecture defined by Network Management Datastore Architecture (<a class="el" href="index.html#rfcs">NMDA RFC</a>). Specifically, <em>startup</em>, <em>running</em>, <em>candidate</em>, and <em>operational</em> datastores are implemented in full compliance to the definitions. Following is a brief description and purpose of each datastore.</p>
<p><em>Startup</em> datastore is the only persistent datastore. It includes the configuration of devices at time of their boot. This configuration is <b>copied</b> into <em>running</em> when the first Sysrepo connection (shared memory) is created <b>after system boot</b>.</p>
<p><em>Running</em> datastore holds the current system configuration. This datastore is edited when a configuration change occured and a device should reconfigure itself. It does not persist across reboots. If desired, it can be copied into <em>startup</em> to rectify this.</p>
<p><em>Candidate</em> datastore is meant to be a place to prepare configuration data without impacting the actual device. Be careful, because the actual use of this datastore is not restricted so it does not behave strictly according to <a class="el" href="index.html#rfcs">NETCONF</a> definition and follows general datastore rules instead (more in <a class="el" href="edit_data.html">Editing Data</a>). The specific features implemented are following. This datastore can be <b>invalid</b> and <b>mirrors</b> <em>running</em> datastore until it is modified. After that it can be reset to this behavior again only by calling <a class="el" href="group__edit__data__api.html#gadffb2f55f24a44730c359f2fdabe6ade" title="Replaces a conventional datastore with the contents of another conventional datastore. If the module is specified, limits the operation only to the specified module. If it is not specified, the operation is performed on all modules. ">sr_copy_config()</a>. Also, <a class="el" href="group__lock__api.html#gaf3efa228679077242d35ccdd127cdc16" title="Locks the data of the specified module or the whole datastore. ">sr_lock()</a> will fail if a session tries to lock this datastore after some changes on it are performed. Finally, whenever <a class="el" href="group__lock__api.html#ga9df946267868947b449572f1cb683f4e" title="Unlocks the data of the specified module or the whole datastore. ">sr_unlock()</a> is performed for whatever reason (session termination), the datastore is also reset to its default state (mirroring <em>running</em>).</p>
<h2>Operational Datastore</h2>
<p><a class="anchor" id="oper_ds"></a> <em>Operational</em> datastore maintains the currently used configuration. Details about what exactly it is supposed to represent can be found in the <a href="https://tools.ietf.org/html/rfc8342#section-5.3">NMDA RFC</a>. In short, it is read-only and generally corresponds to <em>running</em> with some possible differences. Also, only this datastore includes any <b>state data</b> nodes.</p>
<p>By default, this datastore is <b>empty</b>. From user perspective, this is how data becomes a part of this datastore:</p><ul>
<li>any subscribed <em>running</em> data (in-use concept) will appear in <em>operational</em> datastore;</li>
<li>any <a class="el" href="index.html#oper_data">operational data</a>.</li>
</ul>
<p>Note that all <b>notification</b> and <b>RPC/action</b> invocations are <b>validated</b> against this datastore.</p>
<p>Sysrepo also supports the <a href="https://tools.ietf.org/html/rfc8342#section-5.3.4">NMDA origin</a> attribute that appears only in the <em>operational</em> datastore. It is added automatically to all operational data; nodes that do not have their own inherit origin from their parents. However, whenever an application is providing/modifying <a class="el" href="index.html#oper_data">operational data</a>, it can set a specific origin that will be stored.</p>
<h1>Operational Data</h1>
<p><a class="anchor" id="oper_data"></a> These data are found in the <em>operational</em> datastore and the following information applies to <b>all operational data</b>, both <b>state</b> and <b>configuration</b> nodes. Applications can provide them in 2 ways, <b>pull</b> or <b>push</b>.</p>
<p>If employing the pull method, the operational data are always retrieved when they are needed so they are guaranteed to be up-to-date. An application can subscribe to providing these data using an <a class="el" href="subs.html#oper_subs">operational subscription</a>. This method is suitable for data that change often such as some counters or statistics.</p>
<p>As for the second push method, its main principle is that the state data need to be set only when they change. Otherwise they are stored and reused whenever needed without any interaction with the provider client. These data are <a class="el" href="edit_data.html">set normally</a> but they are owned by the client. As soon as the client <a class="el" href="conn_sess.html">disconnects</a>, the data are considered to no longer be in-use and are deleted. This method is suitable for data that do not change often or not at all such as network interface state or basic information about the system.</p>
<p>These methods can be combined and provided data can overlap. Later push data overwrite older stored push data and pull data always overwrite push data.</p>
<p>Note that these data are always appended to in-use <em>running</em> data. That means, for instance, that no state data can exist if their configuration parent does not exist. A consequence of this is that whenever in-use <em>running</em> data change, the stored <em>operational</em> changes (push method) are also adjusted and any invalid data (one without parents) are removed.</p>
<h1>Threading Model</h1>
<p><a class="anchor" id="threads"></a> Firstly, regarding <a class="el" href="conn_sess.html">connections and sessions</a>, a <b>session</b> is not synchronized at all so it <b>must not be shared</b> among multiple threads. Each thread should always create its own session to ensure correct behavior. Other than that there should be no restrictions and all Sysrepo API functions should be correctly synchronized for any number of processes, each with several threads.</p>
<p>As for <a class="el" href="subs.html">subscriptions</a>, it is up to the application to divide its events-of-interest (all <code>*_subscribe()</code> calls) into subscriptions. All events on a subscription are handled together. The usual reason for splitting application events into several subscriptions is to allow for their concurrent handling (such as reacting to configuration changes while notifications are being received).</p>
<p>Every subscription can then be handled in various ways. It can be fully managed by Sysrepo and it will by default create a separate thread that will wait for events on the subscription and process them. But, if your application has a custom event loop, for example, it can <a class="el" href="group__subs__api.html#gae87f7a55b60c13c69d813121778fd1a1">retrieve a file descriptor</a> of a subscription that can be used in <code>poll(2)</code> or <code>select(2)</code> and use it to check for new events. Then, a handler function should be called that will <a class="el" href="group__subs__api.html#gac4dd747c8bc2b3faadcd3ff8047fa26a">process all pending events</a> on the subscription. Alternatively, this handler can also be called periodically without any checking for new events.</p>
<h1>Recovery</h1>
<p><a class="anchor" id="recovery"></a> Because Sysrepo uses shared memory, no automatic OS cleanup is performed in case an application crashes or does not <a class="el" href="group__conn__sess__api.html#ga457a7767f7267497cf800068b6e198b3">properly terminate</a> all its connections. Hence the current state of each connection is continuously updated and stored so that other applications are able to perform the cleanup after a corrupt application.</p>
<p>This cleanup is performed automatically as part of almost every API function. Note that this mechanism is not foolproof and cannot cover all the cases. So, only the most common ones are covered, namely when an application crashes <b>while not executing any Sysrepo function</b> or in an <b>application callback</b> called by Sysrepo. In other words, if the applications crashes in its own code. In case a crash occurs in Sysrepo code, the state may not be recoverable and all the shared memory must be removed in order for Sysrepo to work correctly again.</p>
<h1>Access Control</h1>
<p><a class="anchor" id="access_control"></a> Sysrepo access control relies on file system permissions. Specifically, <em>read</em> and <em>write</em> permissions for specific modules are checked when an operation requiring them is being performed. This is always mentioned in the function documentation.</p>
<p>Permissions are checked for the session user that is inherited from the process owner that created the session. <a class="el" href="group__conn__sess__api.html#ga90b20e8c2e6a99c24b866815b3ab67f3">Changing it</a> is possible if the process owner is <code>root</code> but should be done only if Sysrepo session is created by an application that delegates requests from other sources than the application itself (NETCONF, for example, more in <a class="el" href="conn_sess.html">sessions</a>).</p>
<h1>Path and XPath</h1>
<p><a class="anchor" id="paths"></a> There are <em>xpaths</em> and <em>paths</em> used as parameters for various Sysrepo API functions. Generally, these are <a href="https://www.w3.org/TR/1999/REC-xpath-19991116/">XPath</a> expressions as used by YANG. Differences are outlined below. Note that there is often additional information about what is expected from the particular parameter.</p>
<p><b>XPath</b> accepts any expression that <em>libyang</em> does. But <em>libyang</em> uses <a href="https://tools.ietf.org/html/rfc7951">JSON</a> module prefixes instead of XML prefixes of the module namespaces, which means that simply module names have to be used.</p>
<p><b>Path</b> is similar to <em>XPath</em> defined above with some restrictions. It follows the JSON <a href="https://tools.ietf.org/html/rfc7951#section-6.11">instance-identifier</a> format meaning modules are strictly inherited from parents unless explicitly specified. Additionally, it is possible to use predicates to restrict nodes and wildcards can be used instead of node identifiers (<code>*</code> and <code>.</code>). Do <b>not</b> use spaces unless required (it is fine in literals enclosed in quotes). </p>
</div></div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated on Thu Dec 24 2020 18:12:43 for sysrepo by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.13 </li>
  </ul>
</div>
</body>
</html>
